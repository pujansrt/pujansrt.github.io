<!DOCTYPE HTML> <html lang="en-US"> <head> <title>AppKubos: Scala Introduction</title> <meta http-equiv="content-type" content="text/html; charset=utf-8"/> <meta name="description" content="Scala Java JavaEE"/> <meta name="HandheldFriendly" content="True"/> <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <meta name="referrer" content="origin"/> <link rel="icon" href="/favicon.ico" type="image/x-icon"> <!--[if lte IE 8]><script src="/assets/css/ie/html5shiv.js"></script><![endif]--> <noscript> <link rel="stylesheet" href="/assets/css/skel.css"/> <link rel="stylesheet" href="/assets/css/style.css"/> <link rel="stylesheet" href="/assets/css/style-wide.css"/> </noscript> <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script> <script async src="/assets/js/jquery.dropotron.min.js"></script> <script src="/assets/js/skel.min.js"></script> <script src="/assets/js/skel-layers.min.js"></script> <script src="/assets/js/init.js"></script> <script async src="/assets/js/lunr.min.js"></script> <script async src="/assets/js/search.js"></script> <link rel="alternate" type="application/rss+xml" title="AppKubos" href="http://www.appkubos.com/feed.xml"/> </head> <body> <div id="header"> <nav id="nav"> <ul> <li><a href="/">Home</a></li> <li><a href="/pujan">About</a></li> <li class="headmenu" data-cat="javaee" data-curr="etc"> <a name="JavaEE">JavaEE</a> <ul> <li><a href=""></a></li> <li><a href="/javaee/ws/soapvsrest/">SOAP vs REST</a></li> <li><a href="/javaee/spring/security/credential/">Spring Security Credentails See Password at Session</a></li> <li><a href="/javaee/spring/configuration/">Spring Security Configuration with Form Login</a></li> <li><a href="/javaee/jboss/jspfix/">JBoss Fix for JSP</a></li> <li><a href="/javaee/processbuilder/">How to Run System Commands in Java</a></li> <li><a href="/javaee/jackson/csv-creator/">CSV Creator using Jackson</a></li> <li><a href="/javaee/jaxws/sample-webservice/">JAX-WS Webservices using Annotations</a></li> </ul> </li><li class="headmenu" data-cat="other" data-curr="etc"> <a name="Other">Other</a> <ul> <li><a href=""></a></li> <li><a href="/etc/calendar-next-4-months/">Calendar For Next Four Months</a></li> <li><a href="/etc/curl/">Curl Command</a></li> <li><a href="/etc/http2/">HTTP/2 Explained</a></li> <li><a href="/etc/tshark-commands/">TShark Commands</a></li> <li><a href="/etc/latency/">Latency Comparison</a></li> <li><a href="/etc/scala-introduction/">Scala Introduction</a></li> <li><a href="/etc/groovy-run-from-java/">Run Groovy from Java</a></li> </ul> </li><li class="headmenu" data-cat="python" data-curr="etc"> <a name="Python">Python</a> <ul> <li><a href=""></a></li> <li><a href="/python/tutorial/">Python Tutorial</a></li> <li><a href="/python/file-handling/">Python File Handling</a></li> <li><a href="/python/dictionary/">Python Dictionary</a></li> </ul> </li><li class="headmenu" data-cat="integration" data-curr="etc"> <a name="Integration">Integration</a> <ul> <li><a href=""></a></li> <li><a href="/integration/microservices/">Microservices Explained</a></li> <li><a href="/integration/oauth2/">OAuth2 Architecture</a></li> </ul> </li> </ul> </nav> </div> <section class="wrapper style1"> <div class="container"> <section> <header class="major"> <h2>Scala Introduction</h2> </header> <div class="row"> <div class="12u"> <div class="box post"> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;</span>  <span class="n">scala</span></code></pre></figure> <p><strong>Sample Hello World</strong></p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">scala</span><span class="o">&gt;</span>  <span class="nb">object</span> <span class="n">HelloWorld</span> <span class="p">{</span>
<span class="o">|</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="p">{</span>
<span class="o">|</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="p">}</span>
<span class="o">|</span> <span class="p">}</span>
<span class="n">defined</span> <span class="n">module</span> <span class="n">HelloWorld</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">scala</span><span class="o">&gt;</span>  <span class="n">HelloWorld</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
<span class="n">Hello</span><span class="p">,</span> <span class="n">world</span><span class="err">!</span>
<span class="n">unnamed0</span><span class="p">:</span> <span class="n">Unit</span> <span class="o">=</span> <span class="p">()</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">q</span></code></pre></figure> <p><strong>Scala Script</strong></p> <p>The above Scala program may also be run as a shell script respectively as a batch command (see the examples in the man pages of the scala command). The bash shell script script.sh containing the following Scala code (and shell preamble)</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c">#!/bin/sh</span>
<span class="k">exec</span> <span class="n">scala</span> <span class="s">&quot;$0&quot;</span> <span class="s">&quot;$@&quot;</span>
<span class="err">!</span><span class="c">#</span>
<span class="nb">object</span> <span class="n">HelloWorld</span> <span class="p">{</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">String</span><span class="p">])</span> <span class="p">{</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, world! &quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">.</span><span class="n">toList</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="n">HelloWorld</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="c">#can be run directly from the command shell:</span>
<span class="o">&gt;</span>  <span class="o">./</span><span class="n">script</span><span class="o">.</span><span class="n">sh</span></code></pre></figure> <p>Note: We assume here the file script.sh has execute access and the search path for the scala command is specified in the PATH environment variable.</p> <p><strong>Compilation</strong></p> <p>The scalac command compiles one (or more) Scala source file(s) and generates Java bytecode which can be executed on any standard JVM; the Scala compiler works similarly to javac, the Java compiler of the Java SDK. &gt; scalac HelloWorld.scala By default scalac generates the class files into the current working directory. You may specify a different output directory using the -d option. &gt; scalac -d classes HelloWorld.scala</p> <p><strong>Execution</strong></p> <p>The scala command executes the generated bytecode with the appropriate options: &gt; scala HelloWorld scala allows us to specify command options, such as the -classpath (or -cp) option: &gt; scala -classpath classes HelloWorld The argument of the scala command has to be a top-level object. If that object is followed by the clause extends Application, then all statements contained in that object will be executed; otherwise you have to add a method main which will act as the entry point of your program. Here is how it looks like: object HelloWorld2 extends Application { println(“Hello, world!”) }</p> <p>Scala does almost everything Java does, plus a whole lot of useful functional stuff. There’s a direct analog in Scala for almost everything in Java.</p> <h3>Annotation declaration</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">@interface Foo {

}</pre> </td> <td> <pre class="brush: scala; gutter: true">trait Foo extends StaticAnnotation {

}</pre> </td> </tr> </tbody> </table> <ul> <li>There is no special syntax for annotation definitions.</li> <li>An annotation has to extend scala.Annotation, or one of its sub-traits.</li> <li>Scala’s compiler will stitch it into the necessary bytecode form for use in Scala or Java.</li> </ul> <h3><span id="more-477"></span>Annotation use</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">@Foo
public class Blah {
  @Stuff
  public void doStuff() {}
}</pre> </td> <td> <pre class="brush: scala; gutter: true">@Foo
class Blah {
  @Stuff
  def doStuff(): Unit = ()
}</pre> </td> </tr> </tbody> </table> <ul> <li>Same annotation usage syntax.</li> <li>Annotations are not used very often in Scala.</li> <li>The extra power of lambdas, types and implicits means that the extra-linguistic meta-programming that they are required for in Java often doesn’t need to happen.</li> <li>Annotations can nest, like in Java.</li> </ul> <h3><span style="color: #000000; font-weight: bold;">Array access</span></h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">strs[0]</pre> </td> <td> <pre class="brush: scala; gutter: true">strs(0)</pre> </td> </tr> </tbody> </table> <ul> <li>There is no special syntax for arrays.</li> <li>Anything defining an apply() method can use function-like syntax like this.</li> </ul> <h3>Array assignment</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">strs[0] = 5</pre> </td> <td> <pre class="brush: scala; gutter: true">strs(0) = 5</pre> </td> </tr> </tbody> </table> <ul> <li>There is no special syntax for arrays.</li> <li>Anything defining an update() method can use assignment syntax like this.</li> </ul> <h3>Array creation</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">String[] strs = new String[] {"a", "b"}</pre> </td> <td> <pre class="brush: scala; gutter: true">val strs = Array("a", "b")</pre> </td> </tr> </tbody> </table> <ul> <li>Arrays don’t have privileged syntax; they look the same as other generic collections.</li> <li>Only use them if you need co-location in memory for high performance.</li> <li>Instead of using “new”, we are calling the factory function on the Array object.</li> <li>Abstracts over the different kinds of JVM array representations int[], Object[], long[], etc, using black magic.</li> </ul> <h3>Autoboxing</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Integer a = 4; // box
int a = b; // unbox</pre> </td> <td> <pre class="brush: scala; gutter: true">val a: AnyRef = 4 // box
val b: Int = a.asInstanceOf[Int] // unbox</pre> </td> </tr> </tbody> </table> <ul> <li>Autoboxing and unboxing happens automatically and invisibly.</li> <li>See Primitives.</li> </ul> <h3>Builder</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Point {
  private final int x, y;

  static class Builder {
    int x = 0;
    int y = 0;

    public void withX(int x) { 
      this.x = x; 
    }

    public void withY(int y) { 
      this.y = y 
    }
    public Point build() {...}
  }

  public int getX() {
    return x;
  }

  public int getY() {
    return y;
  }
  // and on and on and on with more fields
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Point(val x: Int = 3, val y = 77)
// x = 5, y = 77
new Point(x = 5)</pre> </td> </tr> </tbody> </table> <ul> <li>Scala has named and default parameters.</li> <li>You can use this with regular constructors and factory methods, no need for builders.</li> </ul> <h3>Casts</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">(Banana)myFruit</pre> </td> <td> <pre class="brush: scala; gutter: true">myFruit.asInstanceOf[Banana]</pre> </td> </tr> </tbody> </table> <ul> <li>Casting doesn’t have a special syntax, it is a method.</li> <li>The syntax is deliberately verbose, to discourage casting.</li> <li>Casts are not very idiomatic Scala; mostly the type system should protect you from having to lie to it.</li> </ul> <h3>Class declaration</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Gumble {}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Gumble</pre> </td> </tr> </tbody> </table> <ul> <li>Everything is public by default.</li> <li>Don’t need braces if there’s no content.</li> </ul> <h3>Class implementing interfaces/mixins</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Shoe implements 
    Shineable, Cobbleable, Wearable {}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Shoe extends Shineable 
    with Cobbleable with Wearable</pre> </td> </tr> </tbody> </table> <ul> <li>The first thing always says “extends”, even if it is a trait.</li> <li>“with” for everything else.</li> <li>This determines the order in which trait mixins are applied.</li> </ul> <h3>Class with constructor, binding to instance variables with accessors</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Point {
  private final int x, y;

  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public int x() { 
    return x; 
  }

  public int y() { 
    return y; 
  }
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Point(val x: Int, val y: Int)</pre> </td> </tr> </tbody> </table> <ul> <li>Adding “val” makes the constructor arg bind to a field of the same name.</li> <li>“Instance variables” are actually hidden; what you call is always an accessor method, that can be overridden.</li> </ul> <h3>Class with constructor, superclass</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Gumble extends Foo {
  public Gumble(String id) {
    super(id)
  }
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Gumble(id: String) extends Foo(id)</pre> </td> </tr> </tbody> </table> <ul> <li>Primary constructor goes in the declaration.</li> <li>Type comes after the identifier.</li> </ul> <h3>Enums</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">enum Suit {SPADES, HEARTS, CLUBS, DIAMONDS}
Suit suit = Suit.SPADES;</pre> </td> <td> <pre class="brush: scala; gutter: true">// Algebraic Data Type (ADT)
sealed trait Suit
case object Spades extends Suit
case object Hearts extends Suit
case object Clubs extends Suit
case object Diamonds extends Suit
val suit: Suit = Spades

// OR

// Enumeration class
object Suit2 extends Enumeration {
  val Spades, Hearts, Clubs, Diamonds = Value
}

val suit2: Suit2.Value = Suit2.Spades</pre> </td> </tr> </tbody> </table> <ul> <li>Scala doesn’t directly support enums; one of the few things in Java that can’t be generated from Scala. People constantly complain about this, but you really don’t need them.</li> <li>There are two techniques commonly used; Algebraic Data Types, which are more general and powerful, and the Enumeration mixin, which is less powerful.</li> <li>ADTs are a closed hierarchy of ordinary classes and objects; here we are using top-level objects, because we require no parameters.</li> <li>“case class” and “case object” is syntax sugar that generates fields, hashcode, equals, toString and factory methods. They are ordinary classes/objects that you could otherwise have defined by hand. Here, “case object” just gives us a toString() the same as the identifier name.</li> <li>The Enumeration mixin defines a type Value; the Value method creates a new value of type Value.</li> <li>Notice that unlike most languages, comma-separated declarations get assigned to every variable in the list, not just the last one.</li> <li>Usually you would prefer ADTs; the Enumeration mixin is quite limited in usage.</li> </ul> <h3>Equality (value)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">obj1.equals(obj2);
primitive1 == primitive1;</pre> </td> <td> <pre class="brush: scala; gutter: true">any1 == any2</pre> </td> </tr> </tbody> </table> <ul> <li>== is a method that everything supports.</li> <li>It calls the equals() method on objects.</li> <li>It checks value equality on primitives.</li> <li>It is null-safe.</li> </ul> <h3>Equality (reference)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">obj1 == obj2</pre> </td> <td> <pre class="brush: scala; gutter: true">obj1 eq obj2</pre> </td> </tr> </tbody> </table> <ul> <li>eq is a method that all objects (any class under AnyRef) support.</li> <li>Reference equality is not usually used in functional programming.</li> <li>If the reference provides object identity, then it implies that the state of the object mutates over time.</li> <li>In FP, identity is usually modelled outside of object instances.</li> </ul> <h3>Factory</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public interface FooFactory {
  public Foo createFoo();
}</pre> </td> <td> <pre class="brush: scala; gutter: true">() =&gt; Foo</pre> </td> </tr> </tbody> </table> <ul> <li>I mean, it’s really just a function, isn’t it.</li> </ul> <h3>For loop</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">for (int i=0; i &lt; max; i++) {
  doStuff(i);
}</pre> </td> <td> <pre class="brush: scala; gutter: true">// Low level equivalent
var i = 0
while (i &lt; max) {
  doStuff(i)
  i += 1
}

// Index counting equivalent
for (i &lt;- 0 until max) {
  doStuff(i)
}

// Obtain index alongside item with combinators
for ((item, i) &lt;- myList.zipWithIndex) {
  doStuff(item, i)
}</pre> </td> </tr> </tbody> </table> <ul> <li>There’s no direct equivalent to the low-level for loop; you would need to use while.</li> <li>No one has used this in Java since 1999 anyway.</li> <li>You can use a for-comprehension if you just want run through a range.</li> <li>start.to(includedEnd).by(step) and start.until(excludedEnd).by(step) are the most common methods used to create range objects.</li> <li>The “to” and “until” methods are supported on all numeric types.</li> <li>The range is a collection, although it doesn’t explicitly store all of the numbers in range, of course.</li> <li>At the cost of an extra iteration, the most concise way to obtain the index alongside elements in a sequence is zipWithIndex.</li> <li>“0 until max” is the same as “0.until(max)”. Any instance method can be written in operator style.</li> </ul> <h3>Foreach loop (functional)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> reversedNames = new ArrayList<String>();
for (String n : nameList) {
  reversedNames.add(n.reverse());
}
return reversedNames;&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">for (n &lt;- nameList) yield n.reverse

// which is sugar for:

nameList.map(_.reverse)</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Using “yield” with a for-comprehension makes it a functional statement, returning the same kind of structure with the transformation applied.</li> <li>This is syntax sugar for calling the shown map() function.</li> <li>The underscore represents the first argument of a closure; it is shorthand for (n =&gt; n.reverse).</li> </ul> <h3>Foreach loop (imperative)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">for (String n : nameList) {
  System.out.println("Hi, " + n);
}</pre> </td> <td> <pre class="brush: scala; gutter: true">for (n &lt;- nameList) {
  println("Hi, " + n)
}

// which is sugar for:

nameList.foreach(n =&gt; println("Hi, " + n)</pre> </td> </tr> </tbody> </table> <ul> <li>The for-comprehension syntax is just sugar for the foreach() method here. Anything that defines a foreach method can use a for-comprehension in this way.</li> <li>The imperative for-comprehension yields () (Unit) as a value.</li> </ul> <h3>Generics</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Foo&lt;A, B&gt; {
  public &lt;X, Y&gt; void blah(X x, Y y) {}
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Foo[A, B] {
  def blah[X, Y](x: X, y: Y): Unit = {}
}</pre> </td> </tr> </tbody> </table> <ul> <li>Same concept, although Scala uses square brackets.</li> </ul> <h3>Generics (lower bound)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Muncher<S super="" Snack=""> {
  public void munch(S munchable) {...}
}&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">class Muncher[S &gt;: Snack] {
  def munch(munchable: S): Unit
}</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Uses the special &gt;: operator instead of “super”.</li> </ul> <h3>Generics (upper bound)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Vendor<S extends="" Snack=""> {
  public S vend() {...}
}&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">class Vendor[S &lt;: Snack] {
  def vend(): S = ...
}</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Uses the special &lt;: operator instead of “extends”.</li> </ul> <h3>Generics (wildcard)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">BurlapSack&lt;?&gt; wildcardSack = new BurlapSack<String>();
BurlapSack rawSack = new BurlapSack();&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val wildcardList: Seq[_] = Vector.empty</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Underscore indicates a wildcard.</li> <li>There are no raw types in Scala; you always have to fill in type parameters.</li> </ul> <h3>Generics (lower-bound wildcard – use-site contravariance)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Muncher&lt;? super Snack&gt; = new Muncher<Food>();&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val muncher: Muncher[_ &gt;: Snack] = new Muncher[Food]</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Uses the special &gt;: operator instead of “super”.</li> <li>If a class is inherently contravariant, it’s better to use declaration-site variance, using – to indicate that S can only be input: <pre class="brush: scala; gutter: true; first-line: 1; highlight: []; ">    class Muncher[-S &gt;: Snack] {
      def munch(munchable: S): Unit = ...
    }
    // Look Ma, no wildcards!
    val muncher: Muncher[Snack] = new Muncher[Food]</pre> </li> </ul> <h3>Generics (upper-bound wildcard – use-site covariance)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Vendor&lt;? extends Snack&gt; vendor = 
    new Vendor<OverpricedCookies>();&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val vendor: Vendor[_ &lt;: Snack] = 
    new Vendor[OverpricedCookies]</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Uses the special &lt;: operator instead of “extends”.</li> <li>If a class is inherently covariant, it’s better to use declaration-site variance, using + to indicate that S can only be output: <pre class="brush: scala; gutter: true; first-line: 1; highlight: []; ">    class Vendor[+S &lt;: Snack] {
      def vend(): S = ...
    }
    // Look Ma, no wildcards!
    val vendor: Vendor[Snack] = new Vendor[OverpricedCookies]</pre> </li> </ul> <h3>If/else (imperative)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">if (cond) {
  doStuff();
}
else {
  otherStuff();
}</pre> </td> <td> <pre class="brush: scala; gutter: true">if (cond) {
  doStuff()
}
else {
  otherStuff()
}</pre> </td> </tr> </tbody> </table> <h3>If/else (functional)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">cond ? stuff : otherStuff</pre> </td> <td> <pre class="brush: scala; gutter: true">if (cond) stuff else otherStuff</pre> </td> </tr> </tbody> </table> <ul> <li>Why have two syntaxes for the same thing? There’s no ternary operator, because it’s redundant.</li> </ul> <h3>Imports</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">import com.baz.Baz;
import com.foo.Frunk;
import com.foo.Bazzle;
import com.foo.bar.*;</pre> </td> <td> <pre class="brush: scala; gutter: true">import com.baz.Baz
import com.foo.{Frunk, Bazzle}
import com.foo.bar._</pre> </td> </tr> </tbody> </table> <ul> <li>You can stack multiple imports from the same package in braces.</li> <li>Underscore means “all” here.</li> </ul> <h3>Increment/Decrement</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">int i;
i++;
++i;
i--;
--i;</pre> </td> <td> <pre class="brush: scala; gutter: true">var i: Int
i += 1
i -= 1</pre> </td> </tr> </tbody> </table> <ul> <li>There are no special pre/post/inc/dec operators.</li> <li>+ is a normal method on Int.</li> <li>Assignment statements have the value of () (Unit), so you can’t embed assignments in other expressions and conditional tests.</li> <li>The = part is assignment shorthand that can apply to any method with a symbolic nameTherefore it all desugars as: <pre class="brush: scala; gutter: true; first-line: 1; highlight: []; ">i = i.+(1)
i = i.-(1)</pre> </li> </ul> <h3>Instance-of check</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">foo instanceof Banana</pre> </td> <td> <pre class="brush: scala; gutter: true">foo.isInstanceOf[Banana]</pre> </td> </tr> </tbody> </table> <ul> <li>Uses a method rather than special syntax.</li> <li>Similar to cast method: asInstanceOf[Type].</li> </ul> <h3>Instance variables with accessors/mutators</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Foo {
  private String muta = "m";

  public String getMuta() {
    return muta;
  }

  public void setMuta(String m) {
    muta = m;
  }
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Foo {
  var muta = "m"
}

// OR fully written out: 

class Foo {
  private var mVar = "m"

  def muta: String = mVar

  def muta_=(m: String): Unit = { mVar = m }
}</pre> </td> </tr> </tbody> </table> <ul> <li>Just writing “var” in the class body will define a field, with an accessor and mutator for that name.</li> <li>You can write the accessors/mutators in full; a method name that ends in “_=” will get natural “a.b = c” assignment syntax sugar.</li> <li>Both of these classes do the same thing.</li> <li>Generally prefer immutable vals to mutable vars.</li> </ul> <h3>Instance variable (immutable) with accessor</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Foo {
  private final int fixed = 5;

  public int getFixed() {
    return fixed;
  }
}</pre> </td> <td> <pre class="brush: scala; gutter: true">class Foo {
  val fixed = 5
}</pre> </td> </tr> </tbody> </table> <ul> <li>“fixed” is the name of an accessor method. The actual field is hidden.</li> </ul> <h3>Interface declaration</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public interface Edible {
  public abstract boolean containsBones();
  public abstract void eatWith(Drink drink);
}</pre> </td> <td> <pre class="brush: scala; gutter: true">trait Edible {
  def containsBones: Boolean
  def eatWith(drink: Drink): Unit
}</pre> </td> </tr> </tbody> </table> <ul> <li>Traits are like interfaces, except they can contain code that gets mixed with the class and other traits.</li> <li>If there is no “=” assignment, then the def/var/val is abstract.</li> <li>“Unit” is the same as “void”.</li> </ul> <h3>List append/prepend (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> list;
new ArrayList<String>(list).add("newvalue");
new ArrayList<String>(list).insert(0, "newvalue")&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">  val list: Seq[String]
  list :+ "newvalue"
  "newvalue" +: list</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>The +: method means “prepend”.</li> <li>The :+ method means “append”.</li> <li>Methods ending in : associate to the right, so the +: call is actually the same as list.+:(“newvalue”)</li> <li>These return new lists, without modifying the old ones.</li> <li>They reuse as much of the old structure as possible.</li> </ul> <h3>List append/prepend (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> list;
list.add("newvalue")
list.insert(0, "newvalue")&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val list: scala.collection.mutable.Buffer[String]
list += "newvalue"
list.insert(0, "newvalue")</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Seqs instead, unless there’s a compelling performance or clarity argument.</li> <li>Similar syntax to Java, but with a += method instead of “add”.</li> </ul> <h3>List concat (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<Foo> list1;
new ArrayList<String>(list1).addAll(list2);&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val list: Seq[Foo]
list1 ++ list2</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>++ is an ordinary method, returning a new list.</li> <li>Neither old list gets modified.</li> <li>The resulting list reuses as much of the old structures as it can.</li> </ul> <h3>List concat (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<Foo> list1;
list1.addAll(list2)&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val list1: scala.collection.mutable.Buffer[Foo]
list1 ++= list2</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Seqs instead, unless there’s a compelling performance or clarity argument.</li> <li>The ++= method mutates the first list.</li> </ul> <h3>List creation (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">??? You could use Guava, or the crappy unmodifiable wrappers.</pre> </td> <td> <pre class="brush: scala; gutter: true">val list: Seq[String] = Vector("hello", "world")</pre> </td> </tr> </tbody> </table> <ul> <li>Seq is the default trait for ordered sequences.</li> <li>Vector is the best default implementation. It has practically constant time access and modification, yet is totally immutable, and shares most of its structure.</li> <li>The companion object of Vector (as with all of the collections) defines an apply() factory method, which will return an efficient implementation for the size you have chosen.</li> </ul> <h3>List creation (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> list = new ArrayList<String>();
list.add("hello");
list.add("world");&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">import scala.collection.mutable
val list: mutable.Seq[String] = mutable.ArrayBuffer("hello", "world")</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Seqs instead, unless there’s a compelling performance or clarity argument.</li> <li>The ArrayBuffer companion object defines an apply() factory method, which produces an appropriate instance of ArrayBuffer.</li> <li>Way better type inference.</li> </ul> <h3>List random access</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> list;
list.get(0);&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val list: Seq[String]
list(0)</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Seq is the default trait for ordered sequences.</li> <li>Seq[A]s actually extend (Int =&gt; A), so they not only look like functions, but are functions.</li> </ul> <h3>List update (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> list;
list.set(3, "newvalue")&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val list: scala.collection.mutable.Buffer[String]
list(3) = "newvalue"</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Seqs instead, unless there’s a compelling performance or clarity argument.</li> <li>Mutable Seqs define an update() method, that enables the special assignment syntax sugar.</li> </ul> <h3>List “update” (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">List<String> oldList;
new ArrayList<String>(oldList).set(3, "newvalue");&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">val oldList: Seq[String]
oldList.updated(3, "newvalue")</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>Returns a new immutable Seq without modifying the old one.</li> <li>Reuses as much of the old structure as it can.</li> </ul> <h3>Map access</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key, Value&gt; map;
map.get(key);</pre> </td> <td> <pre class="brush: scala; gutter: true">val map: Map[Key, Value]
map(key)</pre> </td> </tr> </tbody> </table> <ul> <li>Maps define an apply() function, which allows them to have a function-like access syntax.</li> <li>Immutable Map[K,V]s actually extend (K =&gt; V), so they not only look like functions, but are functions.</li> </ul> <h3>Map concatenation (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key, Value&gt; map;
new HashMap&lt;Key, Value&gt;(map1).putAll(map2);</pre> </td> <td> <pre class="brush: scala; gutter: true">val map1: Map[Key, Value]
map1 ++ map2</pre> </td> </tr> </tbody> </table> <ul> <li>Maps are integrated into Scala’s collection hierarchy as a Iterable[(K, V)].</li> <li>++ is the concatenation method defined on all immutable collections.</li> <li>++ returns a new map, without changing the old ones. Reuses as much of the old maps in memory as possible.</li> </ul> <h3>Map concatenation (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key, Value&gt; map1;
map1.putAll(map2)</pre> </td> <td> <pre class="brush: scala; gutter: true">val map1: scala.collection.mutable.Map[Key, Value]
map1 ++= map2</pre> </td> </tr> </tbody> </table> <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Maps instead, unless there’s a compelling performance or clarity argument.</li> <li>Maps are integrated into Scala’s collection hierarchy as a Iterable[(K, V)].</li> <li>The ++= is a regular method.</li> </ul> <h3>Map creation (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">??? You could use Guava, or the crappy unmodifiable wrappers.</pre> </td> <td> <pre class="brush: scala; gutter: true">val map = Map("foo" -&gt; 5, "bar" -&gt; 6)</pre> </td> </tr> </tbody> </table> <ul> <li>Maps are immutable by default, and have efficient access, “insertion”, “update”, and “remove” characteristics.</li> <li>Everything is implicitly extended with the -&gt; method. It’s actually a regular method that you could have written, that returns a pair.</li> <li>The Map companion object defines an apply() factory method, that produces the most efficient implementation for the map size you’ve defined.</li> <li>Way better type inference.</li> </ul> <h3>Map creation (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
map.put("Potatoes", 5);
map.put("Bananas", 7);</pre> </td> <td> <pre class="brush: scala; gutter: true">import scala.collection.mutable
val map = mutable.Map("Potatoes" -&gt; 5, "Bananas" -&gt; 7)</pre> </td> </tr> </tbody> </table> <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Maps instead, unless there’s a compelling performance or clarity argument.</li> <li>Everything is implicitly extended with the -&gt; method. It’s actually a regular method that you could have written, that returns a pair.</li> <li>The HashMap companion object defines an apply() factory method, that produces the most efficient implementation for the map size you’ve defined so far.</li> <li>Way better type inference.</li> </ul> <h3>Map “insertion”/”update” (immutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key, Value&gt; map;
new HashMap&lt;Key,Value&gt;(map).put(key, value)</pre> </td> <td> <pre class="brush: scala; gutter: true">val map: Map[Key, Value]
map + (key, value)</pre> </td> </tr> </tbody> </table> <ul> <li>The + method returns a new map, without modifying the old one. This is very efficient, and will reuse most of the memory representation of the old one.</li> <li>(“foo”, 44) is syntax sugar for a new Tuple2[String, Int](“foo”, 44). Other length tuples have equivalent syntax.</li> <li>The inserted pair could also be produced with the -&gt; method: “foo” -&gt; 44. -&gt; is an extension method provided on everything.</li> </ul> <h3>Map insertion (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key, Value&gt; map;
map.put(key, value);</pre> </td> <td> <pre class="brush: scala; gutter: true">val map: scala.collection.mutable.Map[Key, Value]
map += (key, value)</pre> </td> </tr> </tbody> </table> <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Maps instead, unless there’s a compelling performance or clarity argument.</li> <li>(“foo”, 44) is syntax sugar for a new Tuple2[String, Int](“foo”, 44). Other length tuples have equivalent syntax.</li> <li>The added pair could also be produced with the -&gt; method: <pre class="brush: scala; gutter: false">"foo" -&gt; 44</pre> The “-&gt;” is an extension method provided on everything.</li> <li>The += is a regular method on the mutable Map.</li> </ul> <h3>Map update (mutable)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Map&lt;Key,Value&gt; map;
map.put(key, value);</pre> </td> <td> <pre class="brush: scala; gutter: true">val map: scala.collection.mutable.Map[Key, Value]
map(key) = value</pre> </td> </tr> </tbody> </table> <ul> <li>Mostly you won’t need the mutable stuff. Use the default immutable Maps instead, unless there’s a compelling performance or clarity argument.</li> <li>Mutable maps define an update() method, which allows them to have this special assignment syntax sugar.</li> </ul> <h3>Method declaration</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public String myMethod(int arg1, boolean arg2) { 
  return "foo"; 
}</pre> </td> <td> <pre class="brush: scala; gutter: true">def myMethod(arg1: Int, arg2: Boolean): String = "foo"</pre> </td> </tr> </tbody> </table> <ul> <li>Methods are introduced with “def”.</li> <li>Return type comes after the method</li> <li>“=” marks the implementation</li> </ul> <h3>Method declaration (abstract)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">abstract int doStuff(int blah);</pre> </td> <td> <pre class="brush: scala; gutter: true">def doStuff(blah: Int): Int</pre> </td> </tr> </tbody> </table> <ul> <li>If there’s no definition provided with “=”, then it’s automatically abstract.</li> </ul> <h3>Null</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">null</pre> </td> <td> <pre class="brush: scala; gutter: true">null</pre> </td> </tr> </tbody> </table> <ul> <li>It’s there for Java interop, but don’t use it. See “Optional value”.</li> </ul> <h3>Optional value</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">String missing = null;
String gotIt = "value";</pre> </td> <td> <pre class="brush: scala; gutter: true">val missing: Option[String] = None
val gotIt: Option[String] = Some("value")</pre> </td> </tr> </tbody> </table> <ul> <li>Option is what you want. Some(x) indicates a value, None indicates its absence.</li> <li>You can actually use “null”, but don’t, ever. It’s just there for Java interop.</li> <li>Option gets treated like a 0- or 1-length collection, and has all the same powerful combinators that collections do, like map, filter, flatMap, and foreach.</li> </ul> <h3>Optional value (dispatch as expression)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">foo == null ? "nope" : "got " + foo;</pre> </td> <td> <pre class="brush: scala; gutter: true">foo.map("got " + _).getOrElse("nope")</pre> </td> </tr> </tbody> </table> <ul> <li>“map” and “getOrElse” are regular methods on Option.</li> <li>The “_” indicates the first arg of a lambda. Shorthand for (x =&gt; “got ” + x).</li> </ul> <h3>Optional value (dispatch as statement)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">if (foo != null) {
  System.out.println("got " + foo)
}
else {
  System.out.println("nope")
}</pre> </td> <td> <pre class="brush: scala; gutter: true">foo match {
  case Some(f) =&gt; println("got " + f)
  case None =&gt; println("nope")
}</pre> </td> </tr> </tbody> </table> <ul> <li>Pattern matching provides a convenient way to dispatch on the optional case.</li> </ul> <h3>Package declaration</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">package blah;</pre> </td> <td> <pre class="brush: scala; gutter: true">package blah</pre> </td> </tr> </tbody> </table> <h3>Primitives</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">int i = 5;
boolean b = true;
char c = 'c';
long L = 55L;
short s = 3;
byte x = 1;
double d = 3.0;
float f = 5.0f;</pre> </td> <td> <pre class="brush: scala; gutter: true">val i: Int = 5
val b: Boolean = true
val c: Char = 'c'
val L: Long = 55L
val s: Short = 3
val x: Byte = 1
val d: Double = 3.0
val f: Float = 5.0f</pre> </td> </tr> </tbody> </table> <ul> <li>The type system is unified; everything, including primitives is a subtype of Any.</li> <li>Autoboxing and unboxing happens automatically and invisibly.</li> <li>All primitives are conceptually objects and support several instance methods.</li> <li>If possible, they will compile to efficient primitive JVM values.</li> <li>Int, Boolean, Char, etc are not keywords — they are class names.</li> </ul> <h3>Printing to stdout</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">System.out.println("Hello!")</pre> </td> <td> <pre class="brush: scala; gutter: true">println("Hello!")</pre> </td> </tr> </tbody> </table> <ul> <li>This is defined in scala.Predef, which automatically gets imported.</li> </ul> <h3>Runtime Type Token</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public <T> T pretendReified(Class<T> token);

Banana b = pretendReified(Banana.class)&lt;/pre&gt;
&lt;/td&gt;
<td>
<pre class="brush: scala; gutter: true">def pretendReified[T: ClassTag](): T
// which is syntax sugar for:
def pretendReified[T](implicit token: ClassTag[T])

val b = pretendReified[Banana]</pre> </td> &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; <ul> <li>We can get around the lack of reified types with a runtime type token, like in Java.</li> <li>If an implicit ClassTag[T] is required, the compiler will insert it; no need to manually provide one.</li> <li>The [A : Foo] syntax is sugar for requiring an implicit parameter of type Foo[A].</li> </ul> <h3>Singleton</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public enum Singleton { INSTANCE }</pre> </td> <td> <pre class="brush: scala; gutter: true">object Singleton</pre> </td> </tr> </tbody> </table> <ul> <li>Scala has top-level singleton objects.</li> <li>These are used as a superior alternative to statics.</li> <li>They can mix in traits, extend classes, and include any functionality that classes or traits do.</li> <li>“Singleton” here is the name of the value; if you want to refer to its type, you can say Singleton.type. In fact, you get the singleton type of of any fixed value with the .type syntax.</li> </ul> <h3>Static factory method</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Foo {
  public static Foo createFoo(String stuff) {
    return new MysteryFoo(stuff);
  }
}
Foo f = Foo.createFoo("stuff");</pre> </td> <td> <pre class="brush: scala; gutter: true">object Foo {
  def apply(stuff: String): Foo = new MysteryFoo(stuff)
}

class Foo
val f: Foo = Foo("stuff")</pre> </td> </tr> </tbody> </table> <ul> <li>The most common idiom for static factory methods is an apply() method on the companion object.</li> <li>All the collections follow this idiom.</li> <li>All case classes follow this idiom.</li> <li>apply() methods allow syntax sugar where the receiver object can be called like a function.</li> </ul> <h3>Static members</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public class Statics {
  public static final int SPIDER_LEGS = 8;

  public static int getHumanLegs() {
    return 2;
  }
}
int n = Statics.SPIDER_LEGS;</pre> </td> <td> <pre class="brush: scala; gutter: true">object Statics {
  val SpiderLegs = 8
  def humanLegs = 2
}
class Statics
val n = Statics.SpiderLegs</pre> </td> </tr> </tbody> </table> <ul> <li>There is no such thing as static in Scala.</li> <li>You can define a top-level object with the same name as your class; this is called a “companion object”, and so you can get the same static access syntax as Java.</li> <li>There are only two namespaces, values and types. The object is a value, the class is a type; that’s why they can have the same name.</li> <li>The object can extend classes and apply mixins, so you can abstract and reuse the functionality much better.</li> <li>The all-capitals syntax is not typically used, because it doesn’t really make sense to differentiate them; they are all really instance accessor methods.</li> </ul> <h3>Strategy</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public interface TaxStrategy {
  public int calculateTax(Citizen c);
}

public void calcTax(TaxStrategy strat) {
  int totalTax = 0;

  for (Citizen c : citizens) {
    totalTax += strat.calculateTax(c);
  }
  return totalTax;
}</pre> </td> <td> <pre class="brush: scala; gutter: true">def calcTax(f: Citizen =&gt; Int) = citizens.map(f).sum</pre> </td> </tr> </tbody> </table> <ul> <li>This is what functions are for.</li> <li>These are the kind of silly concepts that don’t need to exist in your codebase if you have lambdas and function types.</li> </ul> <h3>String concatenation</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">"foo " + something</pre> </td> <td> <pre class="brush: scala; gutter: true">"foo " + something
s"foo ${something}"</pre> </td> </tr> </tbody> </table> <ul> <li>Same + syntax as Java.</li> <li>You can also use the interpolation syntax, by putting an “s” before the string literal, and using the $ sign in the string.</li> </ul> <h3>Try/catch (functional)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">Object value;
try {
  value = calculateValue();
} catch (SomeException e) {
  value = backupValue;
}</pre> </td> <td> <pre class="brush: scala; gutter: true">value = try {
  calculateValue()
} catch {
  case e: SomeException =&gt; backupValue
}</pre> </td> </tr> </tbody> </table> <ul> <li>Like everything else, try/catches are expressions, and always evaluate to a value.</li> <li>The “catch” part expects a regular PartialFunction[Throwable, _]. It allows much more flexible matching than Java’s special syntax. The most common way to provide it is using the pattern-matching block syntax, which is a partial function literal.</li> </ul> <h3>Try/catch/finally (imperative)</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">try {
  doStuff();
}
catch (BlahException e) {
  e.printStackTrace();
}
catch (FooException e) {
  e.printStackTrace();
}
finally {
  System.out.println("done");
}</pre> </td> <td> <pre class="brush: scala; gutter: true">try {
  doStuff()
}
catch {
  case e: BlahException =&gt; e.printStackTrace()
  case e: FooException =&gt; e.printStackTrace()
}
finally {
  println("done")
}</pre> </td> </tr> </tbody> </table> <ul> <li>Almost the same syntax.</li> <li>The “catch” part expects a regular PartialFunction[Throwable, _]. It allows much more flexible matching than Java’s special syntax. The most common way to provide it is using the pattern-matching block syntax, which is a partial function literal.</li> </ul> <h3>Varags</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">public void stuff(String... names) {}

// Varargs call
stuff("foo", "bar")

// Directly call with String[]
stuff(new String[] {"foo", "bar"})</pre> </td> <td> <pre class="brush: scala; gutter: true">def stuff(names: String*)

// Varargs call
stuff("foo", "bar")

// Directly call with Seq[String]
stuff(Seq("foo", "bar"): _*)</pre> </td> </tr> </tbody> </table> <ul> <li>Declaring a varargs method uses * instead of …</li> <li>When directly calling with a pre-built Seq of things, you need to ascribe the value with the special type of _*. This helps avoid unpleasantness and confusion.</li> <li>Actually, any value can be ascribed with a type, which is like an upcast in the compiler, eg (4: Any), which has a compile-time type of Any, and a runtime type of Int.</li> </ul> <h3>Void</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">void doStuff() {}</pre> </td> <td> <pre class="brush: scala; gutter: true">def doStuff(): Unit = ()</pre> </td> </tr> </tbody> </table> <ul> <li>Everything is a value in Scala.</li> <li>void methods actually return a useless primitive value (), called Unit.</li> <li>It compiles to void on the JVM.</li> <li>Assignments, while loops and imperative for-comprehensions also have the value of Unit.</li> </ul> <h3>While loop</h3> <table> <tbody> <tr> <th>Java</th> <th>Scala</th> </tr> <tr> <td> <pre class="brush: java; gutter: true">while (someCondition()) {
  doStuff();
}</pre> </td> <td> <pre class="brush: scala; gutter: true">while (someCondition) {
  doStuff()
}

// OR

@tailrec
def whileLoop(): Unit = {
  if (someCondition) {
    doStuff()
    whileLoop()
  }
}</pre> </td> </tr> </tbody> </table> <ul> <li>The while loop is inherently imperative, and has a value of () (Unit).</li> <li>This is a low level looping construct, the same as Java’s. It is usually only used for high-performance tuning when the various map, flatMap, and filter combinators would be too slow or memory hungry. eg, painting a grid of pixels on screen.</li> <li>A tail-recursive function will compile to the same efficient bytecode as a while loop.</li> <li>The @tailrec annotation is not required, but makes the compiler guarantee that the recursion will reuse the same space on the stack.</li> <li>These are the only ways to simulate Java’s low-level for(;;) loop.</li> </ul> &lt;/div&gt; </T></T></pre></td></tr></tbody></table></String></String></pre></td></tr></tbody></table></String></pre></td></tr></tbody></table></String></pre></td></tr></tbody></table></String></String></pre></td></tr></tbody></table></Foo></pre></td></tr></tbody></table></String></Foo></pre></td></tr></tbody></table></String></pre></td></tr></tbody></table></String></String></String></pre></td></tr></tbody></table></OverpricedCookies></pre></td></tr></tbody></table></Food></pre></td></tr></tbody></table></String></pre></td></tr></tbody></table></S></pre></td></tr></tbody></table></S></pre></td></tr></tbody></table></String></String></pre></td></tr></tbody></table> </div> </div> </div> </section> </div> </section> <div id="footer"> <div class="container"> <div class="row "> <section class="6u"> <h3>More Links to Stuff</h3> <ul class="url"> <li><a href="/etc/calendar-next-4-months/">Calendar For Next Four Months</a></li><li><a href="/javaee/ws/soapvsrest/">SOAP vs REST</a></li><li><a href="/web/regex/">Regex</a></li><li><a href="/javaee/spring/security/credential/">Spring Security Credentails See Password at Session</a></li><li><a href="/etc/curl/">Curl Command</a></li><li><a href="/etc/http2/">HTTP/2 Explained</a></li> </ul> </section> <section class="6u"> <h3>Search Posts</h3> <form action="get" id="site_search"> <input type="text" id="search_box"> <input type="submit" value="Search"> </form> <ul id="search_results"></ul> </section> </div> </div> <ul class="icons"> <li><a href="http://github.com/pujansrt" class="icon fa-github"><span class="label">GitHub</span></a></li> <li><a href="http://www.linkedin.com/in/pujansrt" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li> <li><a href="https://plus.google.com/+PujanSrivastava" class="icon fa-google-plus"><span class="label">Google+</span></a></li> </ul> <div class="copyright"> <ul class="menu"> <li>&copy; Appkubos. All rights reserved 2010-2016</li> </ul> </div> </div> <script>(function(d,e,j,h,f,c,b){d.GoogleAnalyticsObject=f;d[f]=d[f]||function(){(d[f].q=d[f].q||[]).push(arguments)},d[f].l=1*new Date();c=e.createElement(j),b=e.getElementsByTagName(j)[0];c.async=1;c.src=h;b.parentNode.insertBefore(c,b)})(window,document,"script","//www.appkubos.com/assets/js/analytics.js","ga");ga("create","UA-72013918-1","auto");ga("send","pageview");$(function(a){$(".headmenu").each(function(b){var c=$(this);if($(c).attr("data-curr")==$(c).attr("data-cat")){$(c).addClass("current")}});loadAsyncCSS("https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css");loadAsyncCSS("/assets/css/pygments.css")});function loadAsyncCSS(a){if(document.createStyleSheet){document.createStyleSheet(a)}else{$("head").append($("<link rel='stylesheet' href='"+a+"' type='text/css' media='screen' />"))}};</script> </body> </html>